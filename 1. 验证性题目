//1. 验证性题目
//1.1 P123, eg.4-7
#include<iostream>
using namespace std;
class Clock{
	private:
		int hour, minute, second;
	public:
		int getHour() const{return hour;}
		int getMinute() const;
		int getSecond() const;
		void init(int h=0, int m=0, int s=0);
		void setHour(int h);
		void setMinute(int m);
		void setSecond(int s);
		void print();
};
int Clock::getMinute() const{return minute;}
int Clock::getSecond() const{return second;}
void Clock::setHour(int h){
	hour=h;
	if(hour>23) hour=0;
}
void Clock::setMinute(int m){
	minute=m;
	if(minute>59){
		minute=0;
		hour++;
		setHour(hour);
	}
}
void Clock::setSecond(int s){
	second=s;
	if(second>59){
		second=0;
		minute++;
		setMinute(minute);
	}
}
void Clock::print(){
	cout<<hour<<":"<<minute<<":"<<second<<endl;
}
void Clock::init(int h, int m, int s){
	setHour(h);
	setMinute(m);
	setSecond(s);
}
int main(){
	Clock *p1, *p2, clk1, clk2;
	clk1.init(8);
	clk1.print();	//输出 8:0:0
	clk1.setMinute(45);
	clk1.print();	//输出8:45:0
	p1 = &clk1;	//p1指向 clk1
	p1->setSecond(30);
	p1->print();	//输出 8:45:30
	clk2 = clk1;	//对象间的赋值
	clk2.setHour(14);
	clk2.print();	//输出14:45:30
	p2 = new Clock();	//p2指向用 new 创建的对象
	p2->init(15,30,30);
	p2->print();	//输出 15:30:30
	p1 = p2;	//p1和p2指向同一个对象
	p1->print();	//输出 15:30:30
	delete p2;
	p1->print(); 	//异常:指针悬挂
	return 0;
}


//1.2 P162 eg.4-30
//设计一个员工类，做一个简单的公司员工管理的小程序，并能统计从公司成立以来的员工数目。
#include<iostream>
using namespace std;
class Employee{
	int id;
	string name;
	static int count;	//静态数据成员，做计数器用
	public:
		Employee(int id=0, string name="Noname"){
			this->id=id;
			this->name=name;
			count++;	//每新进一个员工，计数器增加1
		}
		int getCount() const{return count;}
		~Employee(){count--;}	//每离职一个员工,计数器减 1
};
int Employee::count=0;	//定义静态数据成员并初始化
int main(){
	Employee e1(1000, "Zhao");	//count:1
	Employee e2(1001, "Qian");	//count:2
	Employee *pe = new Employee(1003, "Sun");	//count:3
	cout<<e1.getCount() <<endl;	//输出3
	{
		Employee e3;	//count:4
		cout<<e3.getCount()<<endl;	//输出 4
	}		//e3被析构，count:3
	cout<<e1.getCount()<<endl;	//输出 3
	delete pe;	//析构用指针指向的对象，count:2
	cout<<e1.getCount()<<endl;	//输出 2
	return 0;
}


//1.3 debug
class X{
	private:
		int a=0, &b;	//a 不应在类中初始化
		const int c;
		void setA(int i){a=i;}
		X(int i){a=i;}	//缺少默认构造函数
	public:
		int X(){a=b=c=0;}	//默认构造函数的实现应与构造函数一样使用初始化列表初始化成员变量
		X(int i, int j, int k){a=i; b=j; c=k;}	//参数列表的变量名应与成员变量名不同
		static void setB(int k){b=k;}	//成员变量b没有被静态函数引用
		setC(int k) const {c=c+k;}	//修改const
};
void main(){
	X x1;
	X x2(3);	//参数应对应构造函数的参数列表
	X x3(1, 2, 3);
	x1.setA(3);
}

//1.4.1 Reading
#include<iostream>
#include<string>
using namespace std;
class X{
	int a;
	char *b;	
	float c;
	public:
		X(int x1, char *x2, float x3):a(x1), c(x3){
			b=new char[sizeof(x2)+1];
			strcpy(b, x2);
		}
		X():a(0), b("X::X()"),c(10){ }
		X(int x1, char*x2="X::X(...)",int x3=10):a(x1),b(x2),c(x3){ }
		X(const X&other){
			a=other.a;
			b="X::X(const X &other)";
			c=other.c;
		}
		void print(){cout<<"a="<<a<<"\t"<<"b="<<b<<"\t"<<"c="<<c<<endl;}
};
int main(){
	X *A=new X(4,"X::X(int, char, float)",32);
	X B, C(10), D(B);
	A->print();	B.print();
	C.print();  D.print();
	return 0;
}

// THE RESULT:
//a=4    b=X::X(int, char, float)    c=32
//a=0    b=X::X()    c=10
//a=10    b=X::X(...)    c=10
//a=0    b=X::X(const X &other)    c=10

//1.4.2 Reading
#include<iostream>
using namespace std;
class A{
	int x;
	public:
		A():x(0){cout<<"constructor A() called..."<<endl; }
		A(int i):x(i){cout<<"X"<<x<<"\tconstructor..."<<endl;}
		~A(){cout<<"X"<<x<<"\tdestructor..."<<endl;}
};
class B{
	int y;
	A X1, X2[3];
	public:
		B(int j):X1(j), y(j){cout<<"B"<<j<<"\tconstructor..."<<endl;}
		~B(){cout<<"B"<<y<<"\tdestructor..."<<endl;}
};
int main(){
	A X1(1), X2(2);
	B B1(3);
	return 0;
}

// THE RESULT:
//X1      constructor...
//X2      constructor...
//X3      constructor...
//constructor A() called...
//constructor A() called...
//constructor A() called...
//B3      constructor...
//B3      destructor...
//X0      destructor...
//X0      destructor...
//X0      destructor...
//X3      destructor...
//X2      destructor...
//X1      destructor...
